#  #JVM
## 一、内存模型

### 1 程序计数器
   线程私有内存，用以保存当前线程所执行的字节码的行号指示器。

### 2 栈内存

#### 2.1 Java虚拟机栈
  线程私有内存，生命周期和线程相同，每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、
动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

#### 2.2 本地方法栈
  与虚拟机栈相似，本地方法栈为虚拟机用到的native方法服务。

### 3 堆内存
  共享内存，存放对象实例和数组，对象当满足JVM的一定编辑优化条件下，为了更好的回收对象，JVM可能执行一
些优化措施把对象在栈上分配内存。JVM也会在共享堆内存上为每个线程划分出一小块线程私有的分配缓冲区。

### 4 方法区
  共享内存，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。很多虚拟机
使用永久代实现方法区，由于永久代垃圾对象回收条件比较严苛，所以这块内存区域收集垃圾效益非常小，虚拟机规范甚至规定不用在方法区实现垃圾收集。

### 5 运行时常量池
  是方法区的一部分，Class文件中华除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，
用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入常量池，例如String.intern()方法。

### 6 直接内存
  并不是运行时数据区的一部分。在JDK1.4中新加入了NIO类，引入了一种基于通道(Channel)与缓冲区
（Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提升性能，因为避免了在java堆中来回复制数据。

## 二、判断对象是否应该被回收

### 1 引用计数法
  给对象添加一个引用计数器，每当一有一个地方引用它时，计数器值就+1，当引用失效时，计数器值-1；当引用
计数器值为0就代表这个对象不可能再被引用，需要回收。简单高效，但是它很难解决对象之间相互循环引用的问题。

### 2 可达性分析算法
  从一系列称为“GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象
到GC Roots没有任务引用链相连，即从GC Roots到这个对象不可达时，，则证明此对象是不可用的，需要被回收。

  要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接
的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finnalize()方法，当对象没有覆盖finalize()方法或finalize（）已经被虚拟机调用过，这2种情况都视为没有必要执行。如果对象有必要执行finalize()，那么这个对象会被放置在一个F-Queue队列中，在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它的finalize()。finalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象在finalize()中成功重新与引用链上的任何一个对象建立关联，那么在第二次标记时它将被移除出“即将回收”的几核；如果对象这时候还没有逃脱，那基本上它就真的可以被回收了。

## 三、垃圾收集算法

### 1 标记-清除算法
  首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。不足之处：1.标记和清除两个过程
效率都不高；2.标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致程序运行过程需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次GC。

### 2 复制算法
  将可用内存分为大小相等两块，每次只使用一块，当这块内存用完了就将还存活的对象复制到另外一块上，然后
再把已使用过的内存空间一次清理掉。这样只要移动堆顶指针，按顺序分配内存即可，也不用考虑内存碎片等复杂情况，实现简单，运行高效。只是这样每次只能使用一半的内存，代价高了点。IBM公司的专门研究表明，新生代中的对象98%是朝生夕死，所以并不需要按照1:1的比例来划分内存空间，而是将内存划分为一块较大的Eden空间和两块较小的survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivvor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor比例是8:1:1,这样只有10%的内存空间会被浪费。但是其实没有办法保证每次回收都只有不多于10%的对象存活，所以当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保。

### 3 标记-整理算法
  复制收集算法对存活率较高时进行较多的复制操作效率将会变低。根据老年代的特点，标记-整理算法标记过程与
标记-清除算法一样吗，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界外的内存。

### 4 分代收集算法
  当前商业虚拟机都采用分代收集。这种算法根据对象存活周期的不同将内存划分为几块。一般分为新生代和老年
代，这样根据各个年代采用最适当的收集算法。新生代每次都有大量对象死去，只有少量存活就才用复制算法，这样只要付出少量的复制成本就可以完成收集；老年代因为对象存活率高、没有额外的空间进行分配担保，就采用标记-清理或者标记-整理算法。

## 四、类加载机制

### 类加载过程
  加载 -> 验证  -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

### 类加载器
  从虚拟机角度来讲只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader)，这个使用C+
+语言实现，是虚拟机自身的一部分；另外一种是所有其他的类加载器，都由Java语言实现，独立于虚拟机外部，并且全部继承与java.lang.ClassLoader。

  从Java开发人员来看，类加载器可以分为三种：

1.启动类加载器：负责加载存放在<JAVA_HOME>/lib目录中的或者被-Xbootclasspath参数所指定的路径中的并且是虚拟机识别的类库。启动类加载器无法直接被java程序所引用，如需把加载请求委派给引导类加载器，那直接使用null代替。

2.扩展类加载器（Extension ClassLoader)：由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>/lib/ext目录中的或者被java.ext.dirs系统变量所指定的路径中的类库，开发者可以直接使用。

3.应用程序类加载器（Application ClassLoader)：由sun.misc.Launcher$AppClassLoader实现，由于这个类加载器是ClassLoader.getSystemClassLoader（）的返回值，所以一般也叫它系统类加载器，负责加载用户类路径上所指定的类库，开发者可以直接使用。

双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器去进行加载，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

双亲委派模型的好处是Java类随着他的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪一个类加载器要加载这个类，最终都是委派给处于顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反则会存在多个不同的Object类，Java类型体系中最基础的行为也就无法保证。