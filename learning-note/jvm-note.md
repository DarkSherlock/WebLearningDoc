#  #JVM
## 一、内存结构

### 1 程序计数器
   线程私有内存，用以保存当前线程所执行的字节码的行号指示器。

### 2 栈内存

#### 2.1 Java虚拟机栈
  线程私有内存，生命周期和线程相同，每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、
动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

#### 2.2 本地方法栈
  与虚拟机栈相似，本地方法栈为虚拟机用到的native方法服务。

### 3 堆内存
  共享内存，存放对象实例和数组，对象当满足JVM的一定编辑优化条件下，为了更好的回收对象，JVM可能执行一
些优化措施把对象在栈上分配内存。JVM也会在共享堆内存上为每个线程划分出一小块线程私有的分配缓冲区。

### 4 方法区
  共享内存，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。很多虚拟机
使用永久代实现方法区，由于永久代垃圾对象回收条件比较严苛，所以这块内存区域收集垃圾效益非常小，虚拟机规范甚至规定不用在方法区实现垃圾收集。

### 5 运行时常量池
  是方法区的一部分，Class文件中华除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，
用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入常量池，例如String.intern()方法。

### 6 直接内存
  并不是运行时数据区的一部分。在JDK1.4中新加入了NIO类，引入了一种基于通道(Channel)与缓冲区
（Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提升性能，因为避免了在java堆中来回复制数据。

## 二、判断对象是否应该被回收

### 1 引用计数法
  给对象添加一个引用计数器，每当一有一个地方引用它时，计数器值就+1，当引用失效时，计数器值-1；当引用
计数器值为0就代表这个对象不可能再被引用，需要回收。简单高效，但是它很难解决对象之间相互循环引用的问题。

### 2 可达性分析算法
  从一系列称为“GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象
到GC Roots没有任务引用链相连，即从GC Roots到这个对象不可达时，，则证明此对象是不可用的，需要被回收。

  要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接
的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finnalize()方法，当对象没有覆盖finalize()方法或finalize（）已经被虚拟机调用过，这2种情况都视为没有必要执行。如果对象有必要执行finalize()，那么这个对象会被放置在一个F-Queue队列中，在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它的finalize()。finalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象在finalize()中成功重新与引用链上的任何一个对象建立关联，那么在第二次标记时它将被移除出“即将回收”的几核；如果对象这时候还没有逃脱，那基本上它就真的可以被回收了。

## 三、垃圾收集算法

### 1 标记-清除算法
  首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。不足之处：1.标记和清除两个过程
效率都不高；2.标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致程序运行过程需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次GC。

### 2 复制算法
  将可用内存分为大小相等两块，每次只使用一块，当这块内存用完了就将还存活的对象复制到另外一块上，然后
再把已使用过的内存空间一次清理掉。这样只要移动堆顶指针，按顺序分配内存即可，也不用考虑内存碎片等复杂情况，实现简单，运行高效。只是这样每次只能使用一半的内存，代价高了点。IBM公司的专门研究表明，新生代中的对象98%是朝生夕死，所以并不需要按照1:1的比例来划分内存空间，而是将内存划分为一块较大的Eden空间和两块较小的survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivvor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor比例是8:1:1,这样只有10%的内存空间会被浪费。但是其实没有办法保证每次回收都只有不多于10%的对象存活，所以当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保。

### 3 标记-整理算法
  复制收集算法对存活率较高时进行较多的复制操作效率将会变低。根据老年代的特点，标记-整理算法标记过程与
标记-清除算法一样吗，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界外的内存。

### 4 分代收集算法
  当前商业虚拟机都采用分代收集。这种算法根据对象存活周期的不同将内存划分为几块。一般分为新生代和老年
代，这样根据各个年代采用最适当的收集算法。新生代每次都有大量对象死去，只有少量存活就才用复制算法，这样只要付出少量的复制成本就可以完成收集；老年代因为对象存活率高、没有额外的空间进行分配担保，就采用标记-清理或者标记-整理算法。

## 四、类加载机制

### 类加载过程
  加载 -> 验证  -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

### 类加载器
  从虚拟机角度来讲只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader)，这个使用C+
+语言实现，是虚拟机自身的一部分；另外一种是所有其他的类加载器，都由Java语言实现，独立于虚拟机外部，并且全部继承与java.lang.ClassLoader。

  从Java开发人员来看，类加载器可以分为三种：

1.启动类加载器（Bootstrap ClassLoader)：负责加载存放在<JAVA_HOME>/lib目录中的或者被-Xbootclasspath参数所指定的路径中的并且是虚拟机识别的类库。启动类加载器无法直接被java程序所引用，如需把加载请求委派给引导类加载器，那直接使用null代替。

2.扩展类加载器（Extension ClassLoader)：由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>/lib/ext目录中的或者被java.ext.dirs系统变量所指定的路径中的类库，开发者可以直接使用。

3.应用程序类加载器（Application ClassLoader)：由sun.misc.Launcher$AppClassLoader实现，由于这个类加载器是ClassLoader.getSystemClassLoader（）的返回值，所以一般也叫它系统类加载器，负责加载用户类路径上所指定的类库，开发者可以直接使用。

4.Android类加载器:

+ DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk
+ PathClassLoader只能加载系统中已经安装过的apk

双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器去进行加载，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

双亲委派模型的好处是Java类随着他的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪一个类加载器要加载这个类，最终都是委派给处于顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反则会存在多个不同的Object类，Java类型体系中最基础的行为也就无法保证。

### 五、Java内存模型(Java Memory Model)

  Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问
差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。

### 原子性
  线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，
就会发生原子性问题。因为线程在执行一个读改写操作时，在执行完读改之后，时间片耗完，就会被要求放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。

### 缓存一致性
  在多核CPU，多线程的场景中，每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线
程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。

  在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自
己的缓存中，关于同一个数据的缓存内容可能不一致。

### 有序性
  除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load->add
->save 有可能被优化成load->save->add 。这就是有序性问题。

  多CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性
问题等，都硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？
最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。

  所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。
为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

  针对上面的这些问题，不同的操作系统都有不同的解决方案，而Java语言为了屏蔽掉底层的差异，定义了一套属
于Java语言的内存模型规范，即Java内存模型。
Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。

### 原子性
  在Java中，为了保证原子性，提供了两个高级的字节码指令**monitorenter**和**monitorexit**。在
**synchronized**的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是**synchronized**。 

因此，在Java中可以使用**synchronized**来保证方法和代码块内的操作是原子性的。

### 可见性
  Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作
为传递媒介的方式来实现的。
Java中的**volatile**关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用**volatile** 来保证多线程操作时变量的可见性。
除了**volatile**，Java中的**synchronized**和**final**两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。

### 有序性
  在Java中，可以使用**synchronized**和**volatile**来保证多线程之间操作的有序性。实现方式有所区别：
**volatile**关键字会禁止指令重排。**synchronized** 关键字保证同一时刻只允许一条线程操作。
好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像**synchronized**关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用**synchronized**的原因。

但是**synchronized**是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。

**JMM**详见：[https://juejin.im/post/5d1ad06b6fb9a07f021a19e8](https://juejin.im/post/5d1ad06b6fb9a07f021a19e8 "https://juejin.im/post/5d1ad06b6fb9a07f021a19e8")